# technical_architecture.md

## 1. High-Level Architecture
FusionFlow operates as a **Hybrid Cloud Application**.
- **Frontend (The Console):** A thick client (Next.js/React) handling the node graph, WebGL rendering, and real-time interaction.
- **Backend (The Orchestrator):** A serverless-ready API handling auth, billing, and—crucially—the *execution graph* of generative tasks.
- **AI Layer (The Swarm):** A collection of 3rd-party state-of-the-art APIs (Fal, Runway, etc.) integrated via a unified interface.

---

## 2. Backend Tech Stack

| Component | Technology | Rationale |
| :--- | :--- | :--- |
| **Framework** | **Next.js 14+ (App Router)** | Analysis: Seamless full-stack type safety. Server Actions for mutations. |
| **Database** | **PostgreSQL** (Neon/Supabase) | Structured data for User Profiles, Project Graphs, and Asset Metadata. |
| **Caching/Queue** | **Redis** (Upstash) | Managing job queues for long-running video generations and caching API responses. |
| **Storage** | **AWS S3 / Cloudflare R2** | Storing generated images/videos. R2 preferred for zero egress fees (high bandwidth app). |
| **ORM** | **Drizzle ORM** | Lightweight, type-safe, best-in-class performance. |
| **Payments** | **Stripe** | Credit-based consumption model logic. |

---

## 3. Core Backend Systems

### 3.1. The Graph Orchestrator (Server-Side)
The user builds a flow on the canvas. When they click "Run", the JSON graph is sent to the backend.
- **Topological Sort:** The backend determines the execution order of nodes.
- **Job Dispatch:** 
    - *Short jobs (Text-to-Image):* Executed immediately via async await (or short-timeout queue).
    - *Long jobs (Video/Training):* Pushed to a Redis BullMQ queue.
- **Status Broadcasting:** Uses **Pusher** or **Server-Sent Events (SSE)** to push real-time progress (0% -> 100%) back to the specific node on the canvas.

### 3.2. Asset Management System
We do not pass Base64 strings between nodes (too memory heavy). We pass **S3 URLs**.
1.  Node A (Image Gen) finishes. 
2.  Backend uploads result to `s3://fusionflow/user_id/project_id/img_123.webp`.
3.  Backend stores metadata in Postgres `Assets` table.
4.  Backend passes the *URL* to Node B (Image-to-Video).

### 3.3. The "Universal API" Proxy
A unified internal service that abstracts the differences between providers.
- `generateImage(prompt, model="flux-pro")` 
- `generateImage(prompt, model="midjourney")`
*Both calls look the same to our internal logic, the Proxy handles the specific payload shaping for Fal.ai vs other providers.*

---

## 4. Data Models (Schema Draft)

### `Projects`
- `id`: UUID
- `graph_state`: JSON (The saved ReactFlow state)
- `variables`: JSON (Global prompts/settings)

### `Generations` (The History Tape)
- `id`: UUID
- `project_id`: UUID
- `node_id`: String (Which node created this?)
- `prompt_snapshot`: Text (What was the prompt at that exact moment?)
- `settings_snapshot`: JSON (CFG, Seed, etc.)
- `output_url`: String
- `cost_computation`: Float (How many credits this used)

---

## 5. Security & Performance
- **Presigned URLs:** Clients upload reference images directly to S3 (bypassing server bandwidth) via secure presigned URLs generated by the backend.
- **Rate Limiting:** A strict token bucket algorithm per user to prevent API cost runaways.
- **Optimistic UI:** The frontend shows "Generating..." immediately, but the backend is the source of truth for the state.
